---
name: Building this Blog (part 2) - SPA Routing
date: 2025-12-16
topics:
  - blog
  - debugging
---

# Building This Blog (part 2) - SPA Routing

<!-- TODO originally a multi-page app when developing locally -->

With the application consolidated into an SPA, the next logical step was
adding proper routing. Commit
[`ee1762b`](https://github.com/Isaac-DeFrain/blog/commit/ee1762b) introduced
SPA routing support:

- Added `vite.config.ts` with an SPA fallback plugin
- Configured the dev server to serve `index.html` for all routes
- Updated `blog.ts` to handle browser navigation (popstate events)
- Enabled URL-based post navigation (e.g., `/welcome`)

This worked beautifully in local development. But then came the deployment challenge.

## The GitHub Pages Deployment Puzzle

When the initial GitHub Actions workflow was created
([`fc25fb6`](https://github.com/Isaac-DeFrain/blog/commit/fc25fb6)), it seemed
straightforward: build the project and deploy to GitHub Pages. However, a
critical issue emerged: **GitHub Pages doesn't natively support SPA routing**.

When users navigated directly to a route like `/welcome` or refreshed the
page, GitHub Pages would return a 404 error because it was looking for an
actual file at that path, not understanding that this was a client-side route.

## The Solution: A 404 Fallback

The breakthrough came in commit
[`5471c3d`](https://github.com/Isaac-DeFrain/blog/commit/5471c3d) - "ci: support
SPA routing". This commit implemented a sophisticated solution:

### The 404.html Strategy

GitHub Pages has a special feature: when it can't find a file, it serves
`404.html` instead. We exploit this by:

1. **Creating a 404.html file** that mirrors the main `index.html` structure.
2. **Processing 404.html during build** to inject the base path and ensure all
   assets load correctly.
3. **Making 404.html load the SPA**, which then reads the original pathname
   from the URL and routes accordingly.

### Base Path Injection

The solution also addressed another GitHub Pages quirk:

> Project repositories are served from `/repo-name/` rather than the root `/`.

The build process:

- Detects the repository name from `GITHUB_REPOSITORY` environment variable
- Injects `window.__BASE_PATH__` as a global variable into both `index.html`
  and `404.html`
- Updates all asset paths to include the base path when needed

### Vite Plugin Architecture

The implementation used custom Vite plugins:

- **`spa-fallback`**: Handles SPA routing in development
- **`inject-base-path`**: Injects the base path into the HTML
- **`copy-blog-files`**: Ensures blog markdown files are available at runtime
- **`process-404`**: Processes `404.html` with base path injection and asset
  path rewriting

<!--
TODO discuss `/src/blogs/manifest.json` for static hosting - cursor says:

The blog reader:

- Fetches manifest.json to get the list of markdown files
- Uses that list to load and parse each blog post

Is it Strictly Necessary?

Not strictly necessary, but it provides:

- Single source of truth for available posts
- Build-time validation (tests verify all posts are included)
- Consistent ordering (files are sorted alphabetically)
- Works in static hosting environments where directory listing isn't available

The manifest is auto-generated by the Vite plugin (in both dev and build modes), so you don't need to maintain it manually. The plugin scans the src/blogs/ directory and generates the manifest automatically.
-->

<!--
### Challenge 1: SPA Routing Not Supported

The most significant challenge was that **GitHub Pages doesn't natively support SPA routing**. When users navigated directly to a route like `/welcome` or refreshed the page, GitHub Pages would return a 404 error because it was looking for an actual file at that path, not understanding that this was a client-side route handled by JavaScript.

**Solution**: We leveraged GitHub Pages' special behavior where it serves
`404.html` when a file isn't found. By creating a `404.html` file that mirrors
the main `index.html` structure and processes it during build to inject the
base path, we ensure that any "missing" route loads the SPA, which then reads
the original pathname from the URL and routes accordingly. This solution is
detailed in [part 2 of this series](building-this-blog-02-spa-routing.md).

### Challenge 2: Base Path Configuration

GitHub Pages serves project repositories from `/repo-name/` rather than the
root `/`. This means all asset paths, API calls, and routing logic needed to
account for this base path. Without proper handling, assets wouldn't load and
routing would break.

**Solution**: The build process detects the repository name from the
`GITHUB_REPOSITORY` environment variable and injects `window.__BASE_PATH__` as a
global variable into both `index.html` and `404.html`. The application code
then uses this base path when constructing fetch URLs and managing navigation.
Vite's `base` configuration is also set to ensure asset paths are correctly
prefixed.

### Challenge 3: Script Injection Timing

A subtle but critical bug emerged where blog posts failed to load because
`window.__BASE_PATH__` wasn't available when the application code executed.
The base path injection script was initially placed just before the closing
`</head>` tag, but Vite's module scripts were loading earlier, causing the
application to run before the base path was defined.

**Solution**: The script injection point was moved to immediately after the
opening `<head>` tag, ensuring the base path variable is defined before any
module scripts execute. This fix was applied to both `index.html` and
`404.html` processing. The details of this debugging process are covered in
[part 3 of this series](building-this-blog-03-script-injection.md).

### Challenge 4: Build-Time Processing

Multiple build-time transformations were needed:

- Injecting base path into HTML files
- Processing `404.html` with path rewriting for assets
- Copying blog markdown files to the dist directory
- Generating a manifest file listing all blog posts

**Solution**: Custom Vite plugins handle all these transformations during the
build process. The plugins run at different stages (buildStart, transformIndexHtml,
closeBundle) to ensure proper ordering and availability of files. This approach
keeps the source code clean while generating production-ready artifacts.
-->
